import "./painless_dict.blobl"


map legacyVolumes {
  root = this.value.map_each(v -> {
    "script": {
      "source": "ctx._source.when=params.when; ctx._source.data.volumes[params.asset]=[\"output\": params.output, \"input\": params.input]; ctx._source.data.balances[params.asset]=params.input-params.output",
      "params": {
        "when": this.when,
        "asset": v.key,
        "input": v.value.input,
        "output": v.value.output
      },
      "lang": "painless"
    },
    "upsert": {
      "data": {
        "address": this.key,
        "volumes": this.value,
        "balances": this.value.map_each(volume -> volume.value.input - volume.value.output),
        "metadata": {}
      },
      "indexed": {
        "address": this.key
      },
      "kind": "ACCOUNT",
      "ledger": this.ledger,
      "when": this.when
    },
  }).values()
}

map volumes {
  root = this.map_each(v -> v.value.map_each(v2 -> {
    "data": {
        "name": v2.key,
        "input": v2.value.input,
        "output": v2.value.output,
        "account": v.key
    },
	"indexed": {
	  "account": v.key,
	  "name": v2.key
	},
	"kind": "ASSET"
  }).values()).values().flatten()
}

map tx {
  root = {
	"data": {
	  "postings": this.postings,
	  "reference": this.reference,
	  "txid": this.txid,
	  "timestamp": this.timestamp,
	  "metadata": if this.metadata { this.metadata } else {{}}
	},
	"indexed": {
	  "reference": this.reference,
	  "txid": this.txid,
	  "timestamp": this.timestamp,
	  "asset": this.postings.map_each(p -> p.asset),
	  "source": this.postings.map_each(p -> p.source),
	  "destination": this.postings.map_each(p -> p.destination),
	  "amount": this.postings.map_each(p -> if p.asset.contains("/") {
		p.amount / range(0, p.asset.split("/").index(1).number()).fold(1, t -> t.tally * 10) # amount / pow(10, decimal part of asset)
	  } else {p.amount})
	},
	"kind": "TRANSACTION"
  }
}

map committedTransactions {
	root = [
		this.payload.transactions.
			map_each(t -> t.apply("tx")).
			map_each(t -> [{
				"index": {
					"_index": env("OPENSEARCH_INDEX"),
					"_id": "TRANSACTION-%s-%s".format(this.ledger, t.data.txid)
				}
			}, t.assign({"data": {"ledger": this.ledger}}).merge({
				"when": this.date,
				"ledger": this.ledger
			})]).
			flatten(),
		this.payload.volumes.apply("volumes").
		    sort(v -> v.right.data.account > v.left.data.account).
			map_each(t -> [{
				"index": {
					"_index": env("OPENSEARCH_INDEX"),
					"_id": "ASSET-%s-%s-%s".format(this.ledger, t.data.account, t.data.name)
				}
			}, t.assign({"data": {"ledger": this.ledger}}).merge({
                "when": this.date,
                "ledger": this.ledger
            })]).
			flatten(),
        this.payload.volumes.
            map_each(t -> t.merge({
                "ledger": this.ledger,
                "when": this.date,
            }).apply("legacyVolumes")).
            values().
            flatten().
            sort_by(t -> t.upsert.data.address).
            map_each(t -> [{
                "update": {
                    "_index": env("OPENSEARCH_INDEX"),
                    "_id": "ACCOUNT-%s-%s".format(this.ledger, t.upsert.data.address)
                }
            }, t.assign({"upsert": {"data": {"ledger": this.ledger}}})]).
            flatten(),
	].flatten()
}

root = this.apply("committedTransactions")
